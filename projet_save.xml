<?xml version="1.0" encoding="iso-8859-1"?>
<lol xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Projet C</title>
  <style>
    
  </style>
  <script type="text/javascript">
   <![CDATA[ 
    var i;
    var night;
   
    var L = 350; //longueur du mur principal
    var l = 200; //largeur du mur principal
	var O = new point(0, 0); //origine de l'ecran
    var Oprim = new point(350-L/4, 350-l/3.33); //origine de la scene (la ou sera situé de le point s[0])
	
	var screen_left_down, screen_left_top, screen_right_down, screen_right_top; //points delimitant la vision du joueur
	
	
	var array_permLeft = new Array(3,11,19,27,28,20,12,4,2,10,18,26,29,21,13,5,1,9,17,25,30,22,14,6,0,8,16,24,31,23,15,7);
	var array_permRight = new Array(24,16,8,0,7,15,23,31,25,17,9,1,6,14,22,30,26,18,10,2,5,13,21,29,27,19,11,3,4,12,20,28);
	var array_permTop = new Array(8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,24,25,26,27,28,29,30,31);
	var array_permBottom = new Array(0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23);
	
	var coeff_o;
    var coeff_f;
    var coeff;
	
	var s;
	
	var walls, loading_walls;
   
	var direction;
	
	var map = new Array()
   
    map[0] = new Array('*','*','*','*','*','*','*','*','*');
    map[1] = new Array('*','*','*','*','*','*',' ',' ','*');
    map[2] = new Array('*',' ',' ',' ',' ','*',' ','*','*');
    map[3] = new Array('*',' ',' ','*',' ','*',' ','*','*');
    map[4] = new Array('*',' ',' ',' ',' ',' ',' ','*','*');
	map[5] = new Array('*','*',' ','*','*','*',' ','*','*');
    map[6] = new Array('*',' ',' ',' ','*','*',' ',' ','*');
    map[7] = new Array('*','*',' ','*','*','*','*',' ','*');
    map[8] = new Array('*','*','*','*','*','*','*','*','*');
   
    var joueur = new Array(2, 1);
	
	

	function initAll(mouvement) //OK
	{
	 etape_deplacement = 0;
	
	 s = initPoints();
	 
	 
	 document.getElementById("pt").innerHTML += "rt :"+screen_right_top.c[0]+","+screen_right_top.c[1]+"<br />";
     document.getElementById("pt").innerHTML += "rd :"+screen_right_down.c[0]+","+screen_right_down.c[1]+"<br />";
	 document.getElementById("pt").innerHTML += "ld :"+screen_left_down.c[0]+","+screen_left_down.c[1]+"<br />"; 
	 document.getElementById("pt").innerHTML += "lt :"+screen_left_top.c[0]+","+screen_left_top.c[1]+"<br />";
	 
	 
	 permLeft = initPerm(array_permLeft);
	 permRight = initPerm(array_permRight); 
	 permTop = initPerm(array_permTop);
	 permBottom = initPerm(array_permBottom);
	 
	 
	 coeff_o = new Array();
     coeff_f = new Array();
     coeff = new Array(); 
	 
	 
     for(i = 0; i <= 1; i++)
      coeff[i] = new Array(); //0 = axe des x ; 1 = axe des y;
	  
	 walls = initWalls();
	 loading_walls = loadMap();
	  

	  showPoints();
	  
	 drawMap(-1);
	 
	 if(mouvement != -1)
	 {
	  if(mouvement == 0) getMovingCoefficients(permLeft);
	  if(mouvement == 1) getMovingCoefficients(permRight);
	  if(mouvement == 2) getMovingCoefficients(permTop);
	  if(mouvement == 3) getMovingCoefficients(permBottom);
	  
	  
	  setTimeout('move(20, '+mouvement+')', 1);
	 }   
	}
	  
    function getTrueCoords(point1) //OK
	{
	 var new_point = new point(0, 0);
	 
	 new_point.c[0] = point1.c[0]  + Oprim.c[0];
	 new_point.c[1] = -point1.c[1] + Oprim.c[1];
	 
	 return new_point;
	}
   
    function wall(p1, p2, p3, p4) //OK
	{
	 this.p1 = p1;
	 this.p2 = p2;
	 this.p3 = p3;
	 this.p4 = p4;
	}
   
    function point(x, y) //OK
	{
	 this.c = new Array();
	 this.c[0] = x;
	 this.c[1] = y;
	}
   
    function drawLine(point1, point2, color) //OK
	{
	 var p1 = getTrueCoords(point1);
	 var p2 = getTrueCoords(point2);
	 
	 var new_line = neo_line.cloneNode(true);
	 new_line.setAttribute("x1", p1.c[0]);
	 new_line.setAttribute("y1", p1.c[1]);
	 new_line.setAttribute("x2", p2.c[0]);
	 new_line.setAttribute("y2", p2.c[1]);
	 
	 
	 if(color == null) new_line.setAttribute("stroke", "black");
	 else new_line.setAttribute("stroke", color);
	 
	 
	 new_line.setAttribute("stroke-width", "1");
	 
	 document.getElementById("scene").appendChild(new_line);
	}
    
	
	function drawWall(wall, color) //OK
	{
	 
	 var p1 = getTrueCoords(wall.p1);
	 var p2 = getTrueCoords(wall.p2);
	 var p3 = getTrueCoords(wall.p3);
	 var p4 = getTrueCoords(wall.p4);
	 
	 var new_wall = neo_wall.cloneNode(true);
	 new_wall.setAttribute("points", p1.c[0]+","+p1.c[1]+" "+p2.c[0]+","+p2.c[1]+" "+p3.c[0]+","+p3.c[1]+" "+p4.c[0]+","+p4.c[1]);
	 
	 if(color != null) new_wall.setAttribute("fill", color);
	 
	 document.getElementById("scene").appendChild(new_wall);
	}
	
	function drawScreen(display_all)
    {
     drawLine(screen_left_down, screen_left_top);
	 drawLine(screen_left_top, screen_right_top);
	 drawLine(screen_right_top, screen_right_down);
	 drawLine(screen_right_down, screen_left_down); 
	 
	 if(display_all)
	 {
	  var ld = getTrueCoords(screen_left_down);
	  var rd = getTrueCoords(screen_right_down);
	  var lt = getTrueCoords(screen_left_top);
	  var rt = getTrueCoords(screen_right_top);
	 
	  var marge = neo_wall.cloneNode(true);
	  marge.setAttribute("points", "0,0 "+screen.width+",0 "+screen.width+","+screen.height+" 0,"+screen.height+" 0,"+lt.c[1]+" "+lt.c[0]+","+lt.c[1]+" "+ld.c[0]+","+ld.c[1]+" "+rd.c[0]+","+rd.c[1]+" "+rt.c[0]+","+rt.c[1]+" 0,"+rt.c[1]+" 0,0");
	  marge.setAttribute("stroke-width", "0")
	 
	  document.getElementById("scene").appendChild(marge);
	 }
    } 
	
	function applicationAffine(coeff, point)
	{
	 this.coeff = coeff;
	 this.point = point;
	 
	 this.getPoint_y = getPoint_y;
	 this.getPoint_x = getPoint_x;
	 
	 function getPoint_y(x)
	 {
	  var y = this.coeff*x + ((this.coeff*(-this.point.c[0]))+this.point.c[1]);
	  
	  return y;
	 }
	 
	 function getPoint_x(y)
	 {
	  var x = (y - ((this.coeff*(-this.point.c[0]))+this.point.c[1]))/this.coeff;
	 
	  return x;
	 }
	}
	
	function drawAll()
	{
	 var nbre_lignes = document.getElementsByTagName('line').length;
     for(i = 0; i < nbre_lignes; i++)
     document.getElementsByTagName('svg')[0].removeChild(document.getElementsByTagName('line')[0]); 
		 
     var nbre_walls = document.getElementsByTagName('polygon').length;
     for(i = 0; i < nbre_walls; i++)
     document.getElementsByTagName('svg')[0].removeChild(document.getElementsByTagName('polygon')[0]); 
	 
	 
	 drawLine(s[0], s[24], "red");
	 drawLine(s[3], s[27], "red");
	 drawLine(s[4], s[28], "red");
	 drawLine(s[7], s[31], "red");
	 
	 drawLine(s[0], s[3], "red");
	 drawLine(s[4], s[7], "red");
	 drawLine(s[24], s[27], "red");
	 drawLine(s[28], s[31], "red");
	 
	 drawLine(s[0], s[7], "blue");
	 drawLine(s[24], s[31], "blue");
	 drawLine(s[27], s[28], "blue");
	 drawLine(s[3], s[4], "blue");
	 
	 
	 drawLine(s[11], s[12], "red");
     drawLine(s[19], s[20], "red");
	 drawLine(s[26], s[29], "red");
     drawLine(s[25], s[30], "red");
	 
	 drawLine(s[16], s[23], "red");
     drawLine(s[8], s[15], "red");
	 drawLine(s[1], s[6], "red");
     drawLine(s[2], s[5], "red");
	 
	 
	 
	 drawLine(s[1], s[25], "red");
     drawLine(s[2], s[26], "red");
	 drawLine(s[5], s[29], "red"); 
	 drawLine(s[6], s[30], "red");
	 
	 drawLine(s[15], s[12], "red");
     drawLine(s[23], s[20], "red");
	 drawLine(s[16], s[19], "red"); 
	 drawLine(s[8], s[11], "red");
	 
	 
	 drawLine(s[9], s[14], "red");
     drawLine(s[10], s[13], "red");
	 drawLine(s[17], s[22], "red"); 
	 drawLine(s[18], s[21], "red");
	 
	 
	 drawScreen();
	 
	 
	}
	
	
	function loadMap() //OK
	{
	 var i, j;
	 
	 var loading_walls = new Array();
	 
	 for(i = 0; i < walls.length; i++)
	 {
	  loading_walls[i] = new Array();
	  for(j = 0; j < walls[i].length; j++)
	   loading_walls[i][j] = 0;
	 }		
		
	 switch(direction)
	 {
	  
	  case 0 :
	  {
	  
	   if(joueur[0] - 3 >= 0)
	   {
	    if(joueur[1] - 1 >= 0 && map[joueur[0] - 3][joueur[1] - 1] == '*')   loading_walls[3][0] = 1;
	    if(map[joueur[0] - 3][joueur[1]] == '*')   loading_walls[3][1] = 1;
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] - 3][joueur[1] + 1] == '*')   loading_walls[3][2] = 1;
	   }
	   if(joueur[0] - 2 >= 0)
	   {
	    if(joueur[1] - 1 >= 0 && map[joueur[0] - 2][joueur[1] - 1] == '*')   {loading_walls[0][0] = 1; loading_walls[3][3] = 1;}
	    if(map[joueur[0] - 2][joueur[1]] == '*')   loading_walls[0][1] = 1;
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] - 2][joueur[1] + 1] == '*')   {loading_walls[0][2] = 1; loading_walls[3][4] = 1;}
	   }
	   if(joueur[0] - 1 >= 0)
	   {
	    if(joueur[1] - 2 >= 0 && map[joueur[0] - 1][joueur[1] - 2] == '*')   loading_walls[0][11] = 1;
	    if(joueur[1] - 1 >= 0 && map[joueur[0] - 1][joueur[1] - 1] == '*')   {loading_walls[1][0] = 1; loading_walls[1][1] = 1;}
	    if(map[joueur[0] - 1][joueur[1]] == '*')   loading_walls[2][0] = 1;
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] - 1][joueur[1] + 1] == '*')   {loading_walls[1][7] = 1; loading_walls[1][6] = 1;}
	    if(joueur[1] + 2 < map[0].length && map[joueur[0] - 1][joueur[1] + 2] == '*')   loading_walls[0][3] = 1;
	   }
	   
	   if(joueur[1] - 2 >= 0 && map[joueur[0]][joueur[1] - 2] == '*')   loading_walls[0][10] = 1;
	   if(joueur[1] - 1 >= 0 && map[joueur[0]][joueur[1] - 1] == '*')   {loading_walls[2][1] = 1; loading_walls[1][2] = 1;}
	   if(joueur[1] + 1 < map[0].length && map[joueur[0]][joueur[1] + 1] == '*')   {loading_walls[2][3] = 1; loading_walls[1][5] = 1;}
	   if(joueur[1] + 2 < map[0].length && map[joueur[0]][joueur[1] + 2] == '*')   loading_walls[0][4] = 1;
	   
	   if(joueur[0] + 1 < map.length)
	   {
	    if(joueur[1] - 2 >= 0 && map[joueur[0] + 1][joueur[1] - 2] == '*')   loading_walls[0][9] = 1;
	    if(joueur[1] - 1 >= 0 && map[joueur[0] + 1][joueur[1] - 1] == '*')   {loading_walls[1][2] = 1; loading_walls[1][3] = 1;}
	    if(map[joueur[0] + 1][joueur[1]] == '*')   loading_walls[2][2] = 1;
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] + 1][joueur[1] + 1] == '*')   {loading_walls[1][4] = 1; loading_walls[1][5] = 1;}
	    if(joueur[1] + 2 < map[0].length && map[joueur[0] + 1][joueur[1] + 2] == '*')   loading_walls[0][5] = 1;
	   }
	   if(joueur[0] + 2 < map.length)
	   {
	    if(joueur[1] - 1 >= 0 && map[joueur[0] + 2][joueur[1] - 1] == '*')   loading_walls[0][8] = 1;
	    if(map[joueur[0] + 2][joueur[1]] == '*')   loading_walls[0][7] = 1;
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] + 2][joueur[1] + 1] == '*')   loading_walls[0][6] = 1;
	   }
	  }
	  break;
	  
	  case 1 :
	  {
	   if(joueur[1] - 3 >= 0)
	   {
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] - 3] == '*')   loading_walls[3][0] = 1;
	    if(map[joueur[0]][joueur[1] - 3] == '*')   loading_walls[3][1] = 1;
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] - 3] == '*')   loading_walls[3][2] = 1;
	   }
	   if(joueur[1] - 2 >= 0)
	   {
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] - 2] == '*')   {loading_walls[0][0] = 1; loading_walls[3][3] = 1;}
	    if(map[joueur[0]][joueur[1] - 2] == '*')   loading_walls[0][1] = 1;
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] - 2] == '*')   {loading_walls[0][2] = 1; loading_walls[3][4] = 1;}
	   }
	   if(joueur[1] - 1 >= 0)
	   {
	    if(joueur[0] + 2 < map.length && map[joueur[0] + 2][joueur[1] - 1] == '*')   loading_walls[0][11] = 1;
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] - 1] == '*')   {loading_walls[1][0] = 1; loading_walls[1][1] = 1;}
	    if(map[joueur[0]][joueur[1] - 1] == '*')   loading_walls[2][0] = 1;
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] - 1] == '*')   {loading_walls[1][7] = 1; loading_walls[1][6] = 1;}
	    if(joueur[0] - 2 >= 0 && map[joueur[0] - 2][joueur[1] - 1] == '*')   loading_walls[0][3] = 1;
	   }
	   
	   if(joueur[0] + 2 < map.length && map[joueur[0] + 2][joueur[1]] == '*')   loading_walls[0][10] = 1;
	   if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1]] == '*')   {loading_walls[2][1] = 1; loading_walls[1][2] = 1;}
	   if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1]] == '*')   {loading_walls[2][3] = 1; loading_walls[1][5] = 1;}
	   if(joueur[0] - 2 >= 0 && map[joueur[0] - 2][joueur[1]] == '*')   loading_walls[0][4] = 1;
	   
	   if(joueur[1] + 1 < map[0].length)
	   {
	    if(joueur[0] + 2 < map.length && map[joueur[0] + 2][joueur[1] + 1] == '*')   loading_walls[0][9] = 1;
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] + 1] == '*')   {loading_walls[1][2] = 1; loading_walls[1][3] = 1;}
	    if(map[joueur[0]][joueur[1] + 1] == '*')   loading_walls[2][2] = 1;
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] + 1] == '*')   {loading_walls[1][4] = 1; loading_walls[1][5] = 1;}
	    if(joueur[0] - 2 >= 0 && map[joueur[0] - 2][joueur[1] + 1] == '*')   loading_walls[0][5] = 1;
	   }
	   if(joueur[1] + 2 < map[0].length)
	   {
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] + 2] == '*')   loading_walls[0][8] = 1;
	    if(map[joueur[0]][joueur[1] + 2] == '*')   loading_walls[0][7] = 1;
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] + 2] == '*')   loading_walls[0][6] = 1;
	   }
	  }
	  break;
	  
	  case 2 :
	  {
	   if(joueur[0] + 3 < map.length)
	   {
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] + 3][joueur[1] + 1] == '*')   loading_walls[3][0] = 1;
	    if(map[joueur[0] + 3][joueur[1]] == '*')   loading_walls[3][1] = 1;
	    if(joueur[1] - 1 >= 0 && map[joueur[0] + 3][joueur[1] - 1] == '*')   loading_walls[3][2] = 1;
	   }
	   if(joueur[0] + 2 < map.length)
	   {
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] + 2][joueur[1] + 1] == '*')   {loading_walls[0][0] = 1; loading_walls[3][3] = 1;}
	    if(map[joueur[0] + 2][joueur[1]] == '*')   loading_walls[0][1] = 1;
	    if(joueur[1] - 1 >= 0 && map[joueur[0] + 2][joueur[1] - 1] == '*')   {loading_walls[0][2] = 1; loading_walls[3][4] = 1;}
	   }
	   if(joueur[0] + 1 < map.length)
	   {
	    if(joueur[1] + 2 < map[0].length && map[joueur[0] + 1][joueur[1] + 2] == '*')   loading_walls[0][11] = 1;
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] + 1][joueur[1] + 1] == '*')   {loading_walls[1][0] = 1; loading_walls[1][1] = 1;}
	    if(map[joueur[0] + 1][joueur[1]] == '*')   loading_walls[2][0] = 1;
	    if(joueur[1] - 1 >= 0 && map[joueur[0] + 1][joueur[1] - 1] == '*')   {loading_walls[1][7] = 1; loading_walls[1][6] = 1;}
	    if(joueur[1] - 2 >= 0 && map[joueur[0] + 1][joueur[1] - 2] == '*')   loading_walls[0][3] = 1;
	   }
	   
	   if(joueur[1] + 2 < map[0].length && map[joueur[0]][joueur[1] + 2] == '*')   loading_walls[0][10] = 1;
	   if(joueur[1] + 1 < map[0].length && map[joueur[0]][joueur[1] + 1] == '*')   {loading_walls[2][1] = 1; loading_walls[1][2] = 1;}
	   if(joueur[1] - 1 >= 0 && map[joueur[0]][joueur[1] - 1] == '*')   {loading_walls[2][3] = 1; loading_walls[1][5] = 1;}
	   if(joueur[1] - 2 >= 0 && map[joueur[0]][joueur[1] - 2] == '*')   loading_walls[0][4] = 1;
	   
	   if(joueur[0] - 1 >= 0)
	   {
	    if(joueur[1] + 2 < map[0].length && map[joueur[0] - 1][joueur[1] + 2] == '*')   loading_walls[0][9] = 1;
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] - 1][joueur[1] + 1] == '*')   {loading_walls[1][2] = 1; loading_walls[1][3] = 1;}
	    if(map[joueur[0] - 1][joueur[1]] == '*')   loading_walls[2][2] = 1;
	    if(joueur[1] - 1 >= 0 && map[joueur[0] - 1][joueur[1] - 1] == '*')   {loading_walls[1][4] = 1; loading_walls[1][5] = 1;}
	    if(joueur[1] - 2 >= 0 && map[joueur[0] - 1][joueur[1] - 2] == '*')   loading_walls[0][5] = 1;
	   }
	   if(joueur[0] - 2 >= 0)
	   {
	    if(joueur[1] + 1 < map[0].length && map[joueur[0] - 2][joueur[1] + 1] == '*')   loading_walls[0][8] = 1;
	    if(map[joueur[0] - 2][joueur[1]] == '*')   loading_walls[0][7] = 1;
	    if(joueur[1] - 1 >= 0 && map[joueur[0] - 2][joueur[1] - 1] == '*')   loading_walls[0][6] = 1;
	   }
	  }
	  break;
	  
	   	  
	  case 3 :
	  {
	   if(joueur[1] + 3 < map[0].length)
	   {
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] + 3] == '*')   loading_walls[3][0] = 1;
	    if(map[joueur[0]][joueur[1] + 3] == '*')   loading_walls[3][1] = 1;
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] + 3] == '*')   loading_walls[3][2] = 1;
	   }
	   if(joueur[1] + 2 < map[0].length)
	   {
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] + 2] == '*')   {loading_walls[0][0] = 1; loading_walls[3][3] = 1;}
	    if(map[joueur[0]][joueur[1] + 2] == '*')   loading_walls[0][1] = 1;
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] + 2] == '*')   {loading_walls[0][2] = 1; loading_walls[3][4] = 1;}
	   }
	   if(joueur[1] + 1 < map[0].length)
	   {
	    if(joueur[0] - 2 >= 0 && map[joueur[0] - 2][joueur[1] + 1] == '*')   loading_walls[0][11] = 1;
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] + 1] == '*')   {loading_walls[1][0] = 1; loading_walls[1][1] = 1;}
	    if(map[joueur[0]][joueur[1] + 1] == '*')   loading_walls[2][0] = 1;
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] + 1] == '*')   {loading_walls[1][7] = 1; loading_walls[1][6] = 1;}
	    if(joueur[0] + 2 < map.length && map[joueur[0] + 2][joueur[1] + 1] == '*')   loading_walls[0][3] = 1;
	   }
	   
	   if(joueur[0] - 2 >= 0 && map[joueur[0] - 2][joueur[1]] == '*')   loading_walls[0][10] = 1;
	   if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1]] == '*')   {loading_walls[2][1] = 1; loading_walls[1][2] = 1;}
	   if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1]] == '*')   {loading_walls[2][3] = 1; loading_walls[1][5] = 1;}
	   if(joueur[0] + 2 < map.length && map[joueur[0] + 2][joueur[1]] == '*')   loading_walls[0][4] = 1;
	   
	   if(joueur[1] - 1 >= 0)
	   {
	    if(joueur[0] - 2 >= 0 && map[joueur[0] - 2][joueur[1] - 1] == '*')   loading_walls[0][9] = 1;
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] - 1] == '*')   {loading_walls[1][2] = 1; loading_walls[1][3] = 1;}
	    if(map[joueur[0]][joueur[1] - 1] == '*')   loading_walls[2][2] = 1;
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] - 1] == '*')   {loading_walls[1][4] = 1; loading_walls[1][5] = 1;}
	    if(joueur[0] + 2 < map.length && map[joueur[0] + 2][joueur[1] - 1] == '*')   loading_walls[0][5] = 1;
	   }
	   if(joueur[1] - 2 >= 0)
	   {
	    if(joueur[0] - 1 >= 0 && map[joueur[0] - 1][joueur[1] - 2] == '*')   loading_walls[0][8] = 1;
	    if(map[joueur[0]][joueur[1] - 2] == '*')   loading_walls[0][7] = 1;
	    if(joueur[0] + 1 < map.length && map[joueur[0] + 1][joueur[1] - 2] == '*')   loading_walls[0][6] = 1;
	   }
	  }
	  break;
	 
	 }
	 
	 return loading_walls;
	 
	}
	
	function drawBlock(numero) 
	{
	 switch(numero)
	 {
	  case 0 :
	   if(loading_walls[0][1]) drawWall(walls[0][1]);
       if(loading_walls[2][0]) drawWall(walls[2][0]);
	  break;
	  
	  case 1 :
	   if(loading_walls[0][0]) drawWall(walls[0][0]);
	   if(loading_walls[0][11]) drawWall(walls[0][11]);
	   if(loading_walls[1][0]) drawWall(walls[1][0]);
	   if(loading_walls[1][1]) drawWall(walls[1][1]);
	  break;
	  
	  case 2 :
	   if(loading_walls[0][2]) drawWall(walls[0][2]);
	   if(loading_walls[0][3]) drawWall(walls[0][3]);
	   if(loading_walls[1][7]) drawWall(walls[1][7]);
	   if(loading_walls[1][6]) drawWall(walls[1][6]);
	  break;
	  
	  case 3 :
	   if(loading_walls[0][10]) drawWall(walls[0][10]);
	   if(loading_walls[2][1]) drawWall(walls[2][1]);
	  break;
	  
	  case 4 :
	   if(loading_walls[0][4]) drawWall(walls[0][4]);
	   if(loading_walls[2][3]) drawWall(walls[2][3]);
	  break;
	  
	  case 5 :
	   if(loading_walls[0][9]) drawWall(walls[0][9]);
	   if(loading_walls[0][8]) drawWall(walls[0][8]);
	   if(loading_walls[1][2]) drawWall(walls[1][2]);
	   if(loading_walls[1][3]) drawWall(walls[1][3]);
	  break;
	  
	  case 6 :
	   if(loading_walls[0][7]) drawWall(walls[0][7]);
	   if(loading_walls[2][2]) drawWall(walls[2][2]);
	  break;
	  
	  case 7 :
	   if(loading_walls[0][5]) drawWall(walls[0][5]);
	   if(loading_walls[0][6]) drawWall(walls[0][6]);
	   if(loading_walls[1][5]) drawWall(walls[1][5]);
	   if(loading_walls[1][4]) drawWall(walls[1][4]);
	  break;
	  
	  
	 }
	}
	
    function drawMap(perm) 
	{
	 var i, j;
	 
	 var nbre_lignes = document.getElementsByTagName('line').length;
     for(i = 0; i < nbre_lignes; i++)
     document.getElementsByTagName('svg')[0].removeChild(document.getElementsByTagName('line')[0]); 
	 
	 var nbre_walls = document.getElementsByTagName('polygon').length;
     for(i = 0; i < nbre_walls; i++)
     document.getElementsByTagName('svg')[0].removeChild(document.getElementsByTagName('polygon')[0]); 
	 
	 drawWall(night, "url(#hill)");
	 
	 if(perm == -1) //-1= immobile, avance ou recule
	 {
	  drawBlock(1);
	  drawBlock(2);
	  drawBlock(0);
	  drawBlock(3);
	  drawBlock(4);
	 }
	 if(perm == 0) //0 = tourne à gauche
	 {
	  if(etape_deplacement < 2) drawBlock(2);
      drawBlock(1); 
	  if(etape_deplacement >= 19) drawBlock(5);
	  drawBlock(0);
	  drawBlock(3);
	  if(etape_deplacement >= 20) drawBlock(6);
	 }
	 else if(perm == 1) //1 = tourne à droite
	 {
	  if(etape_deplacement < 2) drawBlock(1);
      drawBlock(2); 
	  if(etape_deplacement >= 19) drawBlock(7);
	  drawBlock(0);
	  drawBlock(4);
	  if(etape_deplacement >= 20) drawBlock(6);
	 }
	 else if(perm == 2) //-1= immobile, avance ou recule
	 {
	  if(etape_deplacement >= 20)
	  {
	   if(loading_walls[3][0]) drawWall(walls[3][0]);
	   if(loading_walls[3][1]) drawWall(walls[3][1]);
	   if(loading_walls[3][2]) drawWall(walls[3][2]);
	  }
	  if(loading_walls[3][3]) drawWall(walls[3][3]);
	  if(loading_walls[3][4]) drawWall(walls[3][4]);
	  drawBlock(1);
	  drawBlock(2);
	  drawBlock(0);
	  drawBlock(3);
	  drawBlock(4);
	 }
	 else if(perm == 3) //-1= immobile, avance ou recule
	 {
	  drawBlock(1);
	  drawBlock(2);
      if(loading_walls[2][0]) drawWall(walls[2][0]);
	  drawBlock(3);
	  drawBlock(4);
	  if(loading_walls[1][2]) drawWall(walls[1][2]);
	  if(loading_walls[1][5]) drawWall(walls[1][5]);
	  drawBlock(5);
	  drawBlock(7);
	 }
	
	 drawScreen(1);
	}
	
	
	function initPoints() //Initialisation des coordonnées des points et des coins de la zone de vision du joueur OK
	{
	 var i = 0;
	 

	 var s = new Array();
	 
	 s[0] = new point(0, 0);
     s[3] = new point(3*(L/2), 0);
     s[4] = new point(3*(L/2), 1.33*l/3.33);
     s[7] = new point(0, 1.33*l/3.33);
   
   
     s[24] = new point(-21*(L/4), -7*(l/3.33));
     s[27] = new point(s[24].c[0] + 12*L, s[24].c[1]);
     s[31] = new point(s[24].c[0], (1.33*(l/3.33))+7*(l/3.33));
     s[28] = new point(s[27].c[0], s[31].c[1]);
	 
	 

	 while(i <= 24)
	 {
	  s[1+i] = new point(0, 0);
	  s[1+i].c[0] = (2*s[i].c[0]+s[i+3].c[0])/3;
	  s[1+i].c[1] = (2*s[i].c[1]+s[i+3].c[1])/3;
	 
	  s[6+i] = new point(0, 0);
	  s[6+i].c[0] = (2*s[i+7].c[0]+s[i+4].c[0])/3;
	  s[6+i].c[1] = (2*s[i+7].c[1]+s[i+4].c[1])/3;
	 
	 
	  s[2+i] = new point(0, 0);
	  s[2+i].c[0] = (s[i].c[0]+2*s[i+3].c[0])/3;
	  s[2+i].c[1] = (s[i].c[1]+2*s[i+3].c[1])/3;
	 
	  s[5+i] = new point(0, 0);
	  s[5+i].c[0] = (s[i+7].c[0]+2*s[i+4].c[0])/3;
	  s[5+i].c[1] = (s[i+7].c[1]+2*s[i+4].c[1])/3;
	  

	  
	  i += 24
	 }

	 var alpha = new applicationAffine(s[24].c[1]/s[24].c[0], O);
	 var gama = new applicationAffine(-s[24].c[1]/s[24].c[0], s[7]);
	 var beta = new applicationAffine(-s[24].c[1]/s[24].c[0], s[3]);
     var delta = new applicationAffine(s[24].c[1]/s[24].c[0], s[4]);
     
	 
	 
	 s[16] = new point(0, 0);
	 s[16].c[0] = 3*(L/4)-3*L;
	 s[16].c[1] = alpha.getPoint_y(s[16].c[0]);
	  
	 s[23] = new point(0, 0);
	 s[23].c[0] = s[16].c[0];
	 s[23].c[1] = gama.getPoint_y(s[16].c[0]);
	  

	  
	 s[8] = new point(0, 0);
	 s[8].c[0] = -3*(L/4);
	 s[8].c[1] = alpha.getPoint_y(s[8].c[0]);
	  
	 s[15] = new point(0, 0);
	 s[15].c[0] = s[8].c[0];
	 s[15].c[1] = gama.getPoint_y(s[8].c[0]);
	 
	 	 
	 
	 s[19] = new point(0, 0);
	 s[19].c[0] = s[16].c[0] + 6*L;
	 s[19].c[1] = s[16].c[1];
	  
	 s[20] = new point(0, 0);
	 s[20].c[0] = s[23].c[0] + 6*L;
	 s[20].c[1] = s[23].c[1];
	  
	 
	  
	 s[11] = new point(0, 0);
	 s[11].c[0] = s[8].c[0] + 3*L;
	 s[11].c[1] = s[8].c[1];
	  
	 s[12] = new point(0, 0);
	 s[12].c[0] = s[15].c[0] + 3*L;
	 s[12].c[1] = s[15].c[1];
	 
	 
	 var epsilon = new applicationAffine(-s[25].c[1]/(s[1].c[0]-s[25].c[0]), s[1]);
	 s[9] = new point(0, 0);
	 s[9].c[0] = s[8].c[0] + L;
	 s[9].c[1] = epsilon.getPoint_y(s[9].c[0]);
	 
	 s[17] = new point(0, 0);
	 s[17].c[0] = s[16].c[0] + 2*L;
	 s[17].c[1] = epsilon.getPoint_y(s[17].c[0]);
	 
	 
	 var teta = new applicationAffine(s[25].c[1]/(s[1].c[0]-s[25].c[0]), s[6]);
	 s[14] = new point(0, 0);
	 s[14].c[0] = s[15].c[0] + L;
	 s[14].c[1] = teta.getPoint_y(s[14].c[0]);
	 
	 s[22] = new point(0, 0);
	 s[22].c[0] = s[23].c[0] + 2*L;
	 s[22].c[1] = teta.getPoint_y(s[22].c[0]);
	 
	 
	 var omega = new applicationAffine(s[25].c[1]/(s[1].c[0]-s[25].c[0]), s[2]);
	 s[10] = new point(0, 0);
	 s[10].c[0] = s[8].c[0] + 2*L;
	 s[10].c[1] = omega.getPoint_y(s[10].c[0]);
	 
	 s[18] = new point(0, 0);
	 s[18].c[0] = s[16].c[0] + 4*L;
	 s[18].c[1] = omega.getPoint_y(s[18].c[0]);
	 
	 
	 var sigma = new applicationAffine(-s[25].c[1]/(s[1].c[0]-s[25].c[0]), s[5]);
	 s[13] = new point(0, 0);
	 s[13].c[0] = s[15].c[0] + 2*L;
	 s[13].c[1] = sigma.getPoint_y(s[13].c[0]);
	 
	 s[21] = new point(0, 0);
	 s[21].c[0] = s[23].c[0] + 4*L;
	 s[21].c[1] = sigma.getPoint_y(s[21].c[0]);
	 
	 screen_left_down = new point(0, 0);
	 screen_left_down.c[0] = (L/4)-30;
	 screen_left_down.c[1] = epsilon.getPoint_y((L/4)-30);
	 
	 screen_left_top = new point(0, 0);
	 screen_left_top.c[0] = (L/4)-30;
	 screen_left_top.c[1] = teta.getPoint_y((L/4)-30);
	 
	 screen_right_down = new point(0, 0);
	 screen_right_down.c[0] = L+(L/4)+30;
	 screen_right_down.c[1] = omega.getPoint_y(L+(L/4)+30);
	 
	 screen_right_top = new point(0, 0);
	 screen_right_top.c[0] = L+(L/4)+30;
	 screen_right_top.c[1] = sigma.getPoint_y(L+(L/4)+30);
	
	
	 return s;
	}
	
	function initWalls() //Initialisation du tableau contenant les murs OK
	{
	 var i;
	 var walls = new Array();
	 
	 for(i = 0; i <= 3; i++)
	  walls[i] = new Array();
	
	 walls[0][0] = new wall(s[0], s[1], s[6], s[7]);
	 walls[0][1] = new wall(s[1], s[2], s[5], s[6]);
	 walls[0][2] = new wall(s[2], s[3], s[4], s[5]);
	 walls[0][3] = new wall(s[11], s[3], s[4], s[12]);
	 walls[0][4] = new wall(s[19], s[20], s[12], s[11]);
     walls[0][5] = new wall(s[27], s[19], s[20], s[28]);
	 walls[0][6] = new wall(s[26], s[27], s[28], s[29]);
	 walls[0][7] = new wall(s[25], s[26], s[29], s[30]);
	 walls[0][8] = new wall(s[24], s[25], s[30], s[31]);
	 walls[0][9] = new wall(s[24], s[31], s[23], s[16]); 
	 walls[0][10] = new wall(s[16], s[8], s[15], s[23]);
	 walls[0][11] = new wall(s[8], s[0], s[7], s[15]);  
	 
	 walls[1][0] = new wall(s[9], s[1], s[6], s[14]);
	 walls[1][1] = new wall(s[8], s[9], s[14], s[15]);
	 walls[1][2] = new wall(s[16], s[17], s[22], s[23]);
	 walls[1][3] = new wall(s[25], s[17], s[22], s[30]);
     walls[1][4] = new wall(s[26], s[18], s[21], s[29]);
	 walls[1][5] = new wall(s[18], s[19], s[20], s[21]);
	 walls[1][6] = new wall(s[10], s[11], s[12], s[13]);
	 walls[1][7] = new wall(s[10], s[2], s[5], s[13]);
	 
	 walls[2][0] = new wall(s[9], s[10], s[13], s[14]); 
	 walls[2][1] = new wall(s[17], s[9], s[14], s[22]);
	 walls[2][2] = new wall(s[17], s[18], s[21], s[22]);
	 walls[2][3] = new wall(s[18], s[10], s[13], s[21]);

     walls[3][0] = new wall(back[0], back[1], back[6], back[7]);	 
	 walls[3][1] = new wall(back[1], back[2], back[5], back[6]);	
	 walls[3][2] = new wall(back[2], back[3], back[4], back[5]);	
	 walls[3][3] = new wall(back[1], s[1], s[6], back[6]);	
	 walls[3][4] = new wall(back[2], s[2], s[5], back[5]);	
	 
	 
	 var night_left_down = new point(screen_left_top.c[0], s[1].c[1]);
	 var night_right_down = new point(screen_right_top.c[0], s[1].c[1]);
	 
	 night = new wall(screen_left_top, screen_right_top, night_right_down, night_left_down);
	 
	 
	 return walls;
	 
	}
	
	function initPerm(permutation) //OK
	{
	 var i;
	 
	 var new_perm = new Array();

	 for(i = 0; i < permutation.length; i++) 
	  new_perm[i] = s[permutation[i]];

     
	 return new_perm;	
	}
	
	function getMovingCoefficients(perm) //OK
	{
	 var i, j, k, points;
	 
	 
	 //COINS DE LA SCENE GLOBALE//
     /*
	  Pour calculer à tout moment la position d'un point dans la scene lors d'un mouvement, on commence par calculer la position des coins de la scene globale :
	  on recupere leur position originale, puis leur position apres deplacement (grace au tableau de permutations reçu en argument), on calcule la distance à parcourir en 
	  soustrayant les coordonnées de la position d'origine de chaque coin aux coordonnées de la position d'arrivée, puis en divisant le resultat 
	  par le nombre d'etapes constituant le deplacement, on obtient un coefficient pour chaque coordonnée de chaque point.
	  On ajoute alors ce coefficient aux coordonnées du point à chaque etape de deplacement, ce qui permet de le faire se deplacer à sa position d'arrivée (voir fonction move())
	  */
	  
	 points = new Array(0, 3, 4, 7, 24, 27, 28, 31); //ce tableau sert uniquement à reunir dans une boucle les operations qui suivent
	  
	 for(j = 0; j < points.length; j++) //passe les valeurs du tableau qui correspondent aux numeros des points à traiter
	  for(i = 0; i <= 1; i++) //boucle : 0 position sur l'axe x, 1 : position sur l'axe y
	   coeff[i][points[j]] = (perm[points[j]].c[i] - s[points[j]].c[i])/20; //on calcule le coefficient du point traité

	 
	 //POINTS INTERNES DE LA SCENE GLOBALE//
	 /*
	  Pour les autres points, l'application de la methode precedente entraine des decalages lors du deplacement, ce qui entraine des dedoublements de murs.
	  Il faut donc utiliser une autre methode, qui utilise la position des coins precedement traité à tout moment du deplacement.
	  Nous savons que les points internes de la scene globale sont tous situés sur une arrete, delimité 2 coins de la scene.
	  Ainsi, si un point B est situé sur une arrete AC, et que l'on prend A comme origine, il existe un coefficient k tel que k*B = C.
	  Nous allons donc effectuer ce procédé pour chaque point, d'abord determiner les extremité de l'arrete contenant le point, puis ramener l'une des extremité à l'origine,
	  et calculer le coefficient. 
	  Deux coefficient vont etre nessecaire : celui à la position d'origine du point, et celui à la position d'arrivée (en utilisant egalement les positions d'arrivée des
	  extremités de l'arrete.
	  Ainsi, si k1 est le coefficient à l'origine, et k2 est celui à l'arrivée, on sait qu'au cours du mouvement, k1 doit devenir k2, donc a chaque etape du mouvement, on doit avoir
	  pour le point C :  ||AC|| = (k1+((k2-k1)/nbre_detape_de_mouvement)*nbre_detape_deja_effectuee)*||AB||
	  en ayant bien sur prealablement effectué de calcul de la position de B à l'etape en cours.
	  Ce qui suit sert donc a calculer (k2-k1)/nbre_detape_de_mouvement.
	  Grace à cette methode, il n'y a aucun decalage puisque chacun des points est forcement placé sur une arrete.
	  */
	  
	 points = new Array(24, 27, 28, 31); //ces points representent le point B dans l'exemple

     //premiere boucle : points des arretes [s[0]s[24]], [s[3]s[27]], [s[7]s[31]], [s[4]s[28]]
     for(k = 0; k < points.length; k++)
	 {
	  j = points[k]; //on recupere le point de reference
	
	  //on l'exprime par rapport à l'autre extremité de l'arrete (point A dans l'exemple), d'abord à l'origine :
	  var point_ref_prim = new point(s[j].c[0] - s[j-(8*3)].c[0], s[j].c[1] - s[j-(8*3)].c[1]);
	  //puis à l'arrivée
	  var point_ref_ter = new point(perm[j].c[0] - perm[j-(8*3)].c[0], perm[j].c[1] - perm[j-(8*3)].c[1]);
	
	  for(i = (j - 8*2); i <= (j-8); i += 8) //on boucle sur tous les points de l'arrete (2 points par arrete)
	  {
	   //on exprime le point par rapport à l'autre extremité de l'arrete, d'abord à l'origine :
	   var point_prim = new point(s[i].c[0] - s[j-(8*3)].c[0], s[i].c[1] - s[j-(8*3)].c[1]);
	   //puis à l'arrivée 
	   var point_ter = new point(perm[i].c[0] - perm[j-(8*3)].c[0], perm[i].c[1] - perm[j-(8*3)].c[1]);
	   
	   document.getElementById("pt").innerHTML += "point_prim "+i+" : "+point_prim.c[0]+","+point_prim.c[1]+"<br />";
	   document.getElementById("pt").innerHTML += "point_ter "+i+" : "+point_ter.c[0]+","+point_ter.c[1]+"<br />";
	   
	   
	   //en decoule le coefficient à l'origine : norme de AC à l'origine/norme de AB à l'origine
	   coeff_o[i] = (Math.sqrt(Math.pow(point_prim.c[0], 2) + Math.pow(point_prim.c[1], 2)))/(Math.sqrt(Math.pow(point_ref_prim.c[0], 2) + Math.pow(point_ref_prim.c[1], 2)));
	   
	   //puis le coefficient à l'arrivée
	   coeff_a = (Math.sqrt(Math.pow(point_ter.c[0], 2) + Math.pow(point_ter.c[1], 2)))/(Math.sqrt(Math.pow(point_ref_ter.c[0], 2) + Math.pow(point_ref_ter.c[1], 2)));
 
	   //enfin, la variation de coefficient à chaque etapes
	   coeff_f[i] = (coeff_a - coeff_o[i])/20;
	  }
     }
	 
     points = new Array(3, 27, 31, 7);
	
	 //seconde boucle : points des arretes [s[0]s[3]], [s[24]s[27]], [s[4]s[7]], [s[28]s[ 31]]
     for(k = 0; k < points.length; k++)
	 {
	  j = points[k];
	
	  var point_ref_prim = new point(s[j].c[0] - s[j-3].c[0], s[j].c[1] - s[j-3].c[1]);
	  var point_ref_ter = new point(perm[j].c[0] - perm[j-3].c[0], perm[j].c[1] - perm[j-3].c[1]);
	
	  for(i = (j - 2); i <= (j-1); i += 1)
	  {
	   var point_prim = new point(s[i].c[0] - s[j-3].c[0], s[i].c[1] - s[j-3].c[1]);
	   var point_ter = new point(perm[i].c[0] - perm[j-3].c[0], perm[i].c[1] - perm[j-3].c[1]);
	  
	   coeff_o[i] = (Math.sqrt(Math.pow(point_prim.c[0], 2) + Math.pow(point_prim.c[1], 2)))/(Math.sqrt(Math.pow(point_ref_prim.c[0], 2) + Math.pow(point_ref_prim.c[1], 2)));
	  
	   coeff_a = (Math.sqrt(Math.pow(point_ter.c[0], 2) + Math.pow(point_ter.c[1], 2)))/(Math.sqrt(Math.pow(point_ref_ter.c[0], 2) + Math.pow(point_ref_ter.c[1], 2)));

	   coeff_f[i] = (coeff_a - coeff_o[i])/20;
	  }
     }
	 
	 
	 points = new Array(11, 19, 23, 15);
	
	 //troisieme boucle : points des arretes [s[8]s[11]], [s[16]s[19]], [s[20]s[23]], [s[12]s[ 15]]
	 for(k = 0; k < points.length; k++)
	 {
	  j = points[k];
	
	  var point_ref_prim = new point(s[j].c[0] - s[j-3].c[0], s[j].c[1] - s[j-3].c[1]);
	  var point_ref_ter = new point(perm[j].c[0] - perm[j-3].c[0], perm[j].c[1] - perm[j-3].c[1]);
	
	  for(i = (j - 2); i <= (j-1); i += 1)
	  {
	   var point_prim = new point(s[i].c[0] - s[j-3].c[0], s[i].c[1] - s[j-3].c[1]);
	   var point_ter = new point(perm[i].c[0] - perm[j-3].c[0], perm[i].c[1] - perm[j-3].c[1]);
	  
	   coeff_o[i] = (Math.sqrt(Math.pow(point_prim.c[0], 2) + Math.pow(point_prim.c[1], 2)))/(Math.sqrt(Math.pow(point_ref_prim.c[0], 2) + Math.pow(point_ref_prim.c[1], 2)));
	  
	   coeff_a = (Math.sqrt(Math.pow(point_ter.c[0], 2) + Math.pow(point_ter.c[1], 2)))/(Math.sqrt(Math.pow(point_ref_ter.c[0], 2) + Math.pow(point_ref_ter.c[1], 2)));

	   coeff_f[i] = (coeff_a - coeff_o[i])/20;
	  }
     }
	 
	}
	
	function move(etapes_restantes, type_mouvement) //OK
	{
	 var i, j, k, l, points;
	
     etape_deplacement++;
	 etapes_restantes--;

	 
	 points = new Array(0, 3, 4, 7, 24, 27, 28, 31);
	 
	 for(j = 0; j < points.length; j++)
	  for(i = 0; i <= 1; i++)
	   s[points[j]].c[i] = s[points[j]].c[i] + coeff[i][points[j]];

	 
	 
	 points = new Array(24, 27, 28, 31);
	
     for(k = 0; k < points.length; k++)
	 {
	  j = points[k];
	  
	  for(i = (j - 8*2); i <= (j-8); i += 8)
	   for(l = 0; l <= 1; l++)
	    s[i].c[l] = (s[j].c[l] - s[(j - 8*3)].c[l])*(coeff_o[i] + coeff_f[i]*etape_deplacement) + s[(j - 8*3)].c[l];
     }
	  
	 points = new Array(3, 27, 31, 7);
	
     for(k = 0; k < points.length; k++)
	 {
	  j = points[k];
	  
	  for(i = (j - 2); i <= (j-1); i += 1)
	   for(l = 0; l <= 1; l++)
	    s[i].c[l] = (s[j].c[l] - s[(j - 3)].c[l])*(coeff_o[i] + coeff_f[i]*etape_deplacement) + s[(j - 3)].c[l];
	 }
	 
	 points = new Array(11, 19, 23, 15);
	 
	 for(k = 0; k < points.length; k++)
	 {
	  j = points[k];
	 
	  for(i = (j - 2); i <= (j-1); i += 1)
	   for(l = 0; l <= 1; l++)
	    s[i].c[l] = (s[j].c[l] - s[(j - 3)].c[l])*(coeff_o[i] + coeff_f[i]*etape_deplacement) + s[(j - 3)].c[l];  
     }
	 
	 drawMap(type_mouvement);
	 
	 if(etapes_restantes != 0)
	  setTimeout('move('+etapes_restantes+',"'+type_mouvement+'")', 1);
	 else 
	 {
	   showPoints();
	   changeDirection(type_mouvement);
	   changePlace(type_mouvement);
	   initAll(-1);  
	   
	 }
	}
	
	function afficherCoeffs()
    {
    var i, j, k;
    var points = new Array(0, 3, 4, 7, 24, 27, 28, 31);

    for(i = 0; i < 8; i++)
     document.getElementById('pt').innerHTML += "coefficients du point "+points[i]+" : "+coeff[0][points[i]]+", "+coeff[1][points[i]]+"<br />";

    points[0] = 24; points[1] = 27; points[2] = 28; points[3] = 31;

    for(k = 0; k < 4; k++)
     for(i = (points[k] - 8*2); i <= (points[k]-8); i += 8)
      document.getElementById('pt').innerHTML += "coefficients du point "+i+" : origine "+coeff_o[i]+", finale "+coeff_f[i]+"<br/>";


    points[0] = 3; points[1] = 27; points[2] = 31; points[3] = 7;

    for(k = 0; k < 4; k++)
     for(i = (points[k] - 2); i <= (points[k]-1); i += 1)
      document.getElementById('pt').innerHTML += "coefficients du point "+i+" : origine "+coeff_o[i]+", finale "+coeff_f[i]+"<br/>";


    points[0] = 11; points[1] = 19; points[2] = 23; points[3] = 15;

    for(k = 0; k < 4; k++)
     for(i = (points[k] - 2); i <= (points[k]-1); i += 1)
      document.getElementById('pt').innerHTML += "coefficients du point "+i+" : origine "+coeff_o[i]+", finale "+coeff_f[i]+"<br/>";
    }
	
	
	function showPoints()
	{
	 var i;
	 
	 for(i = 0; i < s.length; i++)
	  document.getElementById("pt").innerHTML += "point "+i+" : "+s[i].c[0]+","+s[i].c[1]+"<br />";
	 
	 document.getElementById("pt").innerHTML += "____________________________________________";
	}
	
	function changeDirection(type_mouvement)
	{
	 switch(direction)
	 {
	  case 0:
	   if(type_mouvement == 0) direction = 1;
	   if(type_mouvement == 1) direction = 3;
	  break;
	  
	  case 1:
	   if(type_mouvement == 0) direction = 2;
	   if(type_mouvement == 1) direction = 0;
	  break;
	  
	  case 2:
	   if(type_mouvement == 0) direction = 3;
	   if(type_mouvement == 1) direction = 1
	  break;
	  
	  case 3:
	   if(type_mouvement == 0) direction = 0;
	   if(type_mouvement == 1) direction = 2;
	  break;
	 }
	}
	
	function changePlace(type_mouvement)
	{
	 switch(direction)
	 {
	  case 0:
	   if(type_mouvement == 2) joueur[0] -= 1;
	   if(type_mouvement == 3) joueur[0] += 1;
	  break;
	  
	  case 1:
	   if(type_mouvement == 2) joueur[1] -= 1;
	   if(type_mouvement == 3) joueur[1] += 1;
	  break;
	  
	  case 2:
	   if(type_mouvement == 2) joueur[0] += 1;
	   if(type_mouvement == 3) joueur[0] -= 1;
	  break;
	  
	  case 3:
	   if(type_mouvement == 2) joueur[1] += 1;
	   if(type_mouvement == 3) joueur[1] -= 1;
	  break;
	 }
	}
	
	displayPoints()
	]]>
  </script>
</head>
<body id="body"
   style="position:absolute; z-index:0; left:0%; top:0%; width:100%; height:100%; margin:0px">
   

  
  <svg id="scene" xmlns="http://www.w3.org/2000/svg" version="1.1"
    viewBox="0 0 0 0"
    preserveAspectRatio="xMidYMid slice">
	
	
	<defs>
	<linearGradient id="hill" x1="100%" y1="150%" x2="100%" y2="0%">
            <stop offset="35%" stop-color="white" stop-opacity="0.8"/>
            <stop offset="75%" stop-color="black"/>        
        </linearGradient>
	</defs>

	
    <line id="ligne_tronc" x1="" y1="" x2="" y2="" stroke="" stroke-width="" />
    <polygon id="poly_tronc" points="" stroke="black" fill="white" stroke-width="1" fill-rule="nonzero" />

  </svg>
  <p id="mdr"></p>
  <p id="lool"></p>
  <script type="text/javascript">
  <![CDATA[ 
   var neo_line = document.getElementById("ligne_tronc");
   var neo_wall = document.getElementById("poly_tronc");
  

  
   direction = 3; //0 = haut, 1 = gauche, 2 = bas, 3 = droite
   
   var etape_deplacement = 0;
	
	
   s = initPoints();
   var back = new Array();
	 
   for(i = 0; i <= 7; i++)
   {
     back[i] = new point(0, 0);
	 back[i].c[0] = s[i].c[0];
	 back[i].c[1] = s[i].c[1];
   }
	 

	 
	 
   var permLeft = initPerm(array_permLeft);
   var permRight = initPerm(array_permRight); 
   var permTop = initPerm(array_permTop);
   var permBottom = initPerm(array_permBottom);
   
	 
   coeff_o = new Array();
   coeff_f = new Array();
   coeff = new Array(); 
	 
	 
   for(i = 0; i <= 1; i++)
    coeff[i] = new Array(); //0 = axe des x ; 1 = axe des y;
	  
	 walls = initWalls();
	 loading_walls = loadMap();
	 

	 
	 
	 drawMap(-1);
   
     //getMovingCoefficients(permTop);
	 
	    
     //setTimeout('move(20, 2)', 100);
	
   
  
  ]]>
  </script>
  
  <button onclick="initAll(0);">tourner à gauche</button>
  <button onclick="initAll(1);">tourner à droite</button>
  <button onclick="initAll(2);">aller en avant</button>
  <button onclick="initAll(3);">aller en arriere</button>
  <button onclick="alert(joueur[0]+','+joueur[1]);">position</button>
  
  <p id="pt"></p>
  
 </body>
</lol>